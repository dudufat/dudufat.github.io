= linux内核内存管理之oom
认真
:toc:
:toclevels: 4
:toc-position: left
:source-highlighter: pygments
:icons: font
:sectnums:

== 什么是OOM
....
oom 是out of memory的缩写。对linux而言，内核一般将处理器的虚拟地址空间划分为两个部分。底部比较大的部分用于用户进程，
顶部专门用于内核。可用的物理内存被映射到内核的地址空间中，上层所有的进程不能直接操作物理内存，而是通过页表访问内存。
所以linux运行期间，需要不断的维护页表的申请，回收，再利用以保证程序可以有充足的可利用的内存。

那么，如果某个时刻，由于系统参数配置不当或者系统存在内存泄露等问题，造成了kernel分配page frame时候遇到内存耗尽，无法分配成功。
此时kernek遇到的情况，就是一种oom情形。
....

== OOM造成的后果

* linux kernel 遇到了oom会怎么样？通常内核此时有两种选择：

<1> 系统崩溃并产生堆栈，就是常说的kernel panic,也就是立刻死机

<2> 内核会启动一个机制：OOM Killer，仍然试图继续运行

    * OOM killer（Out-Of-Memory killer),该机制会监控系统中占用内存过大的进程，尤其是那些突然消耗非常大内存的进程，
　　
　　为了防止内存耗尽或者为了保证内核中重要进程有足够内存可以使用，会杀掉该进程，释放一部分内存出来。

== 产生oom的原因

TIP: kernel产生oom，是否说明系统一定内存不足了呢？

* 对于该问题的答案，要分情况来看待，对于 **__#UMA#__**  而言，一般就是内存不足了，但对于 **__#NUMA#__**  而言，并不一定。那么，究竟UMA和NUMA是什么？

=== UMA和NUMA介绍

* UMA计算机（一致内存访问，uniform memory access）,这种类型内核将可用的内存以连续方式组织起来（也可能存在小洞情况以后再总结），在SMP系统中
每个CPU访问各自的内存区都是异样快。简单类似以下图示情况：

image:image/UMA.png[image,600,600,role="center"]

* NUMA计算机（非一致内存访问，non-uniform memory access）,这种类型总是多处理器计算机，系统的每个CPU都有本地内存，各个CPU之间通过总线连接起来
所以每个CPU都可以访问其它处理器的本地内存，但是访问速度上会慢一些。简单图示如下图：

image:image/NUMA.png[image,600,600,role="center"]

* 那么，为何说在NUMA系统上，产生oom并非一定是内存不足了呢？请看下一节介绍










[options=interactive]
- [*] 完成BUG
- [ ] 写总结
